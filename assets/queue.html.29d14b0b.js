import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as p,c as o,a as n,b as c,d as a,f as t,r as i}from"./app.4684ad3e.js";const l={},u=t(`<h1 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h1><h2 id="队列是什么" tabindex="-1"><a class="header-anchor" href="#队列是什么" aria-hidden="true">#</a> 队列是什么</h2><ol><li><p>一个先进先出的数据结构</p></li><li><p>js中没有队列，但可以用数组实现队列功能，使用shift()和push()</p></li></ol><h2 id="什么场景用队列" tabindex="-1"><a class="header-anchor" href="#什么场景用队列" aria-hidden="true">#</a> 什么场景用队列</h2><ol><li>需要先进先出的场景</li><li>排队打饭，js异步中的任务队列，计算最近请求次数</li></ol><h2 id="leetcode-最近的请求次数" tabindex="-1"><a class="header-anchor" href="#leetcode-最近的请求次数" aria-hidden="true">#</a> leetcode：最近的请求次数</h2><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p><p>请你实现 RecentCounter 类：</p><p>RecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 保证 每次对 ping 的调用都使用比之前更大的 t 值。</p><p>示例：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：
[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="解题步骤" tabindex="-1"><a class="header-anchor" href="#解题步骤" aria-hidden="true">#</a> 解题步骤</h4><ol><li>有新请求就入队，3000ms前发出的请求出队</li><li>队列的长度就是最近请求次数</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">RecentCounter</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化队列</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 输入 inputs = [[],[1],[100],[3001],[3002]] 请求间隔为 3000ms</span>
<span class="token comment">// 输出 outputs = [null,1,2,3,3]   </span>

<span class="token comment">// 时间复杂度 O(n) n为剔出老请求的长度</span>
<span class="token comment">// 空间复杂度 O(n) n为最近请求的次数</span>
<span class="token class-name">RecentCounter</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">ping</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">t</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果传入的时间小于等于最近请求的时间，则直接返回0</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>

  <span class="token comment">// 将传入的时间放入队列</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 如果队头小于 t - 3000 则剔除队头</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> t <span class="token operator">-</span> <span class="token number">3000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 返回最近请求的次数</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>q<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="前端与队列-js异步中的任务队列" tabindex="-1"><a class="header-anchor" href="#前端与队列-js异步中的任务队列" aria-hidden="true">#</a> 前端与队列：js异步中的任务队列</h2><h4 id="js是单线程的" tabindex="-1"><a class="header-anchor" href="#js是单线程的" aria-hidden="true">#</a> js是单线程的</h4><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h4 id="eventloop和任务队列" tabindex="-1"><a class="header-anchor" href="#eventloop和任务队列" aria-hidden="true">#</a> EventLoop和任务队列</h4><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><p>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</p><p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>具体来说，异步执行的运行机制如下。</p>`,24),r=n("li",null,"所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。",-1),d=n("li",null,'主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。',-1),k=n("li",null,'一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。',-1),v={href:"https://postimg.cc/Bjv90pp4",target:"_blank",rel:"noopener noreferrer"},m=n("img",{src:"https://i.postimg.cc/FHy90nJd/4-ZQ07-78-JP-1-Y3-NN8-J-3.png",alt:"4-ZQ07-78-JP-1-Y3-NN8-J-3.png",loading:"lazy"},null,-1),h=t(`<h4 id="task-宏任务-和-microtask-微任务" tabindex="-1"><a class="header-anchor" href="#task-宏任务-和-microtask-微任务" aria-hidden="true">#</a> Task（宏任务）和 MicroTask（微任务）</h4><table><thead><tr><th>宏任务</th><th>微任务</th></tr></thead><tbody><tr><td>script环境</td><td>Promise的then/catch回调</td></tr><tr><td>setInterval/setTimeout 定时器</td><td>Object.observe</td></tr><tr><td>requestAnimationFrame 浏览器的帧循环</td><td>Proxy</td></tr><tr><td>UI Rendering 浏览器的UI渲染(先忽略),AJAX,DOM</td><td>process.nextTick</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/affbd0b68f2d4ad4b8af436d538483e0.png" alt="" loading="lazy"></p><p>Event Loop中，每一次循环称为tick，每一次tick的任务如下：</p><p>执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去执行Task（宏任务），每次宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会先执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;3&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;4&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;5&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;6&#39;</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;7&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行过程如下</p><ol><li><p>全局打印1</p></li><li><p>创建定时器，宏任务未执行</p></li><li><p>创建Promise对象是同步，先执行打印5（new一个Promise时会同步执行里面的log语句）</p></li><li><p>再次全局打印7</p></li><li><p>会去查找异步任务中是否有待执行的微任务，执行微任务.then打印6</p></li><li><p>当异步任务里面的所有微任务都执行完之后，会去查找宏任务里面的符合条件的宏任务，执行宏任务定时器</p></li><li><p>进入主线程，打印2</p></li><li><p>同步代码创建Promise对象，打印3</p></li><li><p>执行微任务.then打印4</p></li></ol><p>所以最终的结果为：1,5,7,6,2,3,4</p><h4 id="异步面试题" tabindex="-1"><a class="header-anchor" href="#异步面试题" aria-hidden="true">#</a> 异步面试题</h4>`,10),b={href:"https://postimg.cc/9DVqM59y",target:"_blank",rel:"noopener noreferrer"},g=n("img",{src:"https://i.postimg.cc/0yKGV92X/7-CYWMBYUF-WHS27-I4-WDNR.png",alt:"7-CYWMBYUF-WHS27-I4-WDNR.png",loading:"lazy"},null,-1),f=n("p",null,"打印顺序是什么？",-1),_=n("p",null,"答案：2，1",-1),y={href:"https://postimg.cc/7GmQKdwT",target:"_blank",rel:"noopener noreferrer"},q=n("img",{src:"https://i.postimg.cc/yxH48CGn/10-G-BEFOW-f0-0-IZ2-CN-V.png",alt:"10-G-BEFOW-f0-0-IZ2-CN-V.png",loading:"lazy"},null,-1),x=n("p",null,"setTimeout异步任务交给webAPI，继续执行后面代码，将回调函数放入任务队列（等主事件先打印完）",-1);function w(C,j){const s=i("ExternalLinkIcon");return p(),o("div",null,[u,n("ol",null,[r,d,k,n("li",null,[c("主线程不断重复上面的第三步。 "),n("a",v,[m,a(s)])])]),h,n("p",null,[n("a",b,[g,a(s)])]),f,_,n("p",null,[n("a",y,[q,a(s)])]),x])}const P=e(l,[["render",w],["__file","queue.html.vue"]]);export{P as default};
