import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as s,a as e,d as r,b as t,f as o,r as a}from"./app.4684ad3e.js";const c={},h=e("h1",{id:"dns",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dns","aria-hidden":"true"},"#"),t(" DNS")],-1),p={href:"https://postimg.cc/5XtgfyFk",target:"_blank",rel:"noopener noreferrer"},d=e("img",{src:"https://i.postimg.cc/bwxBH2Y8/640.png",alt:"640.png",loading:"lazy"},null,-1),_={href:"http://www.pzijun.cn",target:"_blank",rel:"noopener noreferrer"},u={href:"https://postimg.cc/CRzFkCqC",target:"_blank",rel:"noopener noreferrer"},D=e("img",{src:"https://i.postimg.cc/Dwc8VBfN/640-1.png",alt:"640-1.png",loading:"lazy"},null,-1),g=e("h2",{id:"域名结构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#域名结构","aria-hidden":"true"},"#"),t(" 域名结构")],-1),P=e("p",null,"DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：",-1),N=e("li",null,"根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址",-1),S={href:"http://apple.com",target:"_blank",rel:"noopener noreferrer"},f={href:"http://apple.com",target:"_blank",rel:"noopener noreferrer"},m={href:"http://www.pzijun.cn",target:"_blank",rel:"noopener noreferrer"},T={href:"http://www.pzijun.cn",target:"_blank",rel:"noopener noreferrer"},C={href:"https://postimg.cc/CZmDKTWM",target:"_blank",rel:"noopener noreferrer"},b=e("img",{src:"https://i.postimg.cc/9MjBJcb9/640-2.png",alt:"640-2.png",loading:"lazy"},null,-1),w={href:"http://pzijun.com",target:"_blank",rel:"noopener noreferrer"},k={href:"http://pzijun.com",target:"_blank",rel:"noopener noreferrer"},I={href:"http://www.pzijun.cn",target:"_blank",rel:"noopener noreferrer"},x=e("strong",null,"缓存",-1),z=e("h2",{id:"域名缓存优化",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#域名缓存优化","aria-hidden":"true"},"#"),t(" 域名缓存优化")],-1),U=e("p",null,"域名缓存有以下两种方式：",-1),j=e("ul",null,[e("li",null,"非权威域名服务器（本地域名服务器）缓存 ：各大运营服务商或大公司都有自己的 DNS 服务器，一般部署在距离用户较近地方，代替用户用户访问核心 DNS 系统，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址 本地计算机 DNS 记录缓存 ："),e("li",null,"浏览器缓存 ：浏览器在获取某一网站域名的实际 IP 地址后，进行缓存，之后遇到同一域名查询之前的缓存结果即可，有效减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS"),e("li",null,"操作系统缓存 ：操作系统里有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是 /etc/hosts ，在 Windows 里是 C:\\WINDOWS\\system32\\drivers\\etc\\hosts ，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件")],-1),y={href:"https://postimg.cc/6TG7kv5p",target:"_blank",rel:"noopener noreferrer"},v=e("img",{src:"https://i.postimg.cc/NGd1r63m/640-3.png",alt:"640-3.png",loading:"lazy"},null,-1),M=o('<h2 id="dns查询方式" tabindex="-1"><a class="header-anchor" href="#dns查询方式" aria-hidden="true">#</a> DNS查询方式</h2><p>DNS 查询有两种方式：<strong>递归</strong> 和 <strong>迭代</strong> 。</p><p>一般来说，DNS 客户端设置使用的 DNS 服务器一般都是 递归服务器 ，它负责全权处理客户端的 DNS 查询请求，直到返回最终结果</p><p>而 DNS 根域名服务器之间一般采用 迭代查询 方式，以免根域名服务器的压力过大</p><h3 id="迭代查询" tabindex="-1"><a class="header-anchor" href="#迭代查询" aria-hidden="true">#</a> 迭代查询</h3>',5),E={href:"https://postimg.cc/jLxDLk4L",target:"_blank",rel:"noopener noreferrer"},L=e("img",{src:"https://i.postimg.cc/7Y70tFCM/640-4.png",alt:"640-4.png",loading:"lazy"},null,-1),B=e("h3",{id:"递归查询",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#递归查询","aria-hidden":"true"},"#"),t(" 递归查询")],-1),V={href:"https://postimg.cc/pmyyBh7v",target:"_blank",rel:"noopener noreferrer"},F=e("img",{src:"https://i.postimg.cc/L83f2j3J/640-5.png",alt:"640-5.png",loading:"lazy"},null,-1),H=o('<h2 id="dns-完整查询过程" tabindex="-1"><a class="header-anchor" href="#dns-完整查询过程" aria-hidden="true">#</a> DNS 完整查询过程</h2><p>将我们上面所说的域名服务器之间的 DNS 查询请求过程和域名缓存结合起来，完整查询过程👇：</p><ol><li>首先搜索 浏览器的 DNS 缓存 ，缓存中维护一张域名与 IP 地址的对应表</li><li>如果没有命中😢，则继续搜索 操作系统的 DNS 缓存</li><li>如果依然没有命中🤦‍♀️，则操作系统将域名发送至 本地域名服务器 ，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是 递归查询 ）</li><li>若本地域名服务器的 DNS 缓存没有命中🤦‍，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行 迭代查询 （注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</li></ol><ul><li>首先本地域名服务器向根域名服务器发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul><ol start="5"><li>本地域名服务器 将得到的 IP 地址返回给操作系统，同时自己将 IP 地址 缓存 起来📝</li><li>操作系统 将 IP 地址返回给浏览器，同时自己也将 IP 地址 缓存 起来📝</li><li>至此， 浏览器 就得到了域名对应的 IP 地址，并将 IP 地址 缓存 起来📝</li></ol>',5),W={href:"https://postimg.cc/xX78pjDz",target:"_blank",rel:"noopener noreferrer"},G=e("img",{src:"https://i.postimg.cc/Gp3D29Xq/640-6.png",alt:"640-6.png",loading:"lazy"},null,-1),R=e("p",null,"这些远程查询都是基于UDP协议，通常使用 53 号端口。",-1),X=e("h2",{id:"为什么选择基于-udp-协议发起-dns-查询-而不是-tcp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#为什么选择基于-udp-协议发起-dns-查询-而不是-tcp","aria-hidden":"true"},"#"),t(" 为什么选择基于 UDP 协议发起 DNS 查询，而不是 TCP？")],-1),q=e("p",null,"衡量计算机通信快慢的指标是 响应时间 ，即从用户发出通信指令（输入网址敲回车键）开始，到用户看到完整页面为止，所花费的时间。即：",-1),J=e("p",null,"响应时间 = DNS域名解析时间 + TCP 连接建立时间 + HTTP交易时间",-1),Y=e("p",null,"其中，TCP 连接建立需要三次挥手，HTTP交易一来一回，都不可能减少（具体计算过程可见 说一下HTTP/3新特性，为什么选择使用UDP协议？ ），所以只能让DNS域名解析的时间越小越好",-1),A=e("p",null,"如果 DNS 查询继续采用 TCP 连接？TCP 作为可靠的传输协议，TCP 建立连接会带来以下的额外开销：",-1),K=e("h3",{id:"tcp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#tcp","aria-hidden":"true"},"#"),t(" TCP")],-1),O={href:"https://postimg.cc/947M63CN",target:"_blank",rel:"noopener noreferrer"},Z=e("img",{src:"https://i.postimg.cc/vmPV6MjM/640-7.png",alt:"640-7.png",loading:"lazy"},null,-1),Q=o('<p>使用 TCP 协议（共 330 字节）:</p><ul><li>三次握手 — 14x3(Ethernet) + 20x3(IP) + 44 + 44 + 32 字节</li><li>查询协议头 — 14(Ethernet) + 20(IP) + 20(TCP) 字节</li><li>响应协议头 — 14(Ethernet) + 20(IP) + 20(TCP) 字节</li></ul><hr><p>需要注意的是，我们在这里计算结果的前提是 DNS 解析器只需要与一个命名服务器或者权威服务器进行通信就可以获得 DNS 响应，但是在实际场景中，DNS 解析器可能会递归地与多个命名服务器进行通信，这也加倍地放大了 TCP 协议在额外开销上的劣势。</p><hr><h3 id="udp" tabindex="-1"><a class="header-anchor" href="#udp" aria-hidden="true">#</a> UDP</h3><p>如果使用 UDP 协议（共 84 字节）</p><ul><li>查询协议头 — 14(Ethernet) + 20(IP) + 8(UDP) 字节</li><li>响应协议头 — 14(Ethernet) + 20(IP) + 8(UDP) 字节</li><li>如果 DNS 查询的请求体和响应分别是 15 和 70 字节，那么 TCP 相比于 UDP 协议会增加 ~250 字节和 ~145% 的额外开销</li></ul><p>所以当请求体和响应的大小比较小时，通过 TCP 协议进行传输不仅需要传输更多的数据，还会消耗更多的资源，多次通信以及信息传输带来的时间成本在 DNS 查询较小时是无法被忽视的，TCP 连接带来的可靠性在 DNS 的场景中没能发挥太大的作用。</p><p>UDP 传输的弱点 由于历史的原因，互联网上物理链路的最小 MTU = 576 ，基于 UDP 传输的 DNS 为了限制报文不超过 576 ，所以将 DNS 报文限制在 512 字节。</p><p>这样一旦 DNS 查询应答超过 512 字节，基于 UDP 的 DNS 就只有截短为 512 字节，那么用户得到的 DNS 应答就是不完整的。</p><p>为了克服这种困难，我们第一次在 DNS 协议中明确了 『当 DNS 查询被截断时，应该使用 TCP 协议进行重试』 这一规范。尽管交易时间可能比较长，但毕竟可以得到完整的答案，总比得到不完整的答案要好。</p><p>同时，当数据包足够大的时候，TCP 三次握手带来的额外开销比例就会越来越小，与整个包的大小相比就会趋近于 0：</p>',13),$={href:"https://postimg.cc/N5d5T7db",target:"_blank",rel:"noopener noreferrer"},ee=e("img",{src:"https://i.postimg.cc/52VvhsLc/640-8.png",alt:"640-8.png",loading:"lazy"},null,-1),te=e("p",null,"RFC6891 中引入了 EDNS 机制，它允许我们使用 UDP 最多传输 4096 字节的数据，但是由于 MTU 的限制导致的传输数据分片以及丢失（在实际生产中，一旦数据包中的数据超过了传送链路的最大传输单元MTU，当前数据包就可能会被分片传输、丢弃），使得这一特性不够可靠；",-1),ne=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),t(" 总结")],-1),re=e("p",null,"需要注意的是，DNS 使用了 UDP 协议来获取域名对应的 IP 地址，这个没错，但有些片面，准确的来说，DNS 查询在刚设计时主要使用 UDP 协议进行通信，而 TCP 协议也是在 DNS 的演进和发展中被加入到规范的：",-1),oe=e("ol",null,[e("li",null,"DNS 在设计之初就在区域 传输中引入了 TCP 协议 ， 在查询中使用 UDP 协议 ，它同时占用了 UDP 和 TCP 的 53 端口"),e("li",null,"当 DNS 超过了 512 字节的限制，我们第一次在 DNS 协议中明确了 『当 DNS 查询被截断时，应该使用 TCP 协议进行重试』 这一规范；"),e("li",null,"随后引入的 EDNS 机制允许我们使用 UDP 最多传输 4096 字节的数据，但是由于 MTU 的限制导致的数据分片以及丢失，使得这一特性不够可靠；"),e("li",null,"在最近的几年，我们重新规定了 DNS 应该同时支持 UDP 和 TCP 协议，TCP 协议也不再只是重试时的选择；")],-1);function le(ie,se){const n=a("ExternalLinkIcon");return i(),s("div",null,[h,e("p",null,[e("a",p,[d,r(n)]),t(" DNS（Domain Name System：域名系统），与 HTTP、FTP 和 SMTP 一样，DNS 协议也是应用层的协议，用于将用户提供的主机名（域名）解析为 IP 地址。")]),e("p",null,[t("简单来说，DNS 就像是一个自动的电话号码簿，我们可以直接拨打 47.105.127.0 呼叫对方，但这不方便记录、记忆，DNS 提供一种手段能够让我们直接拨打对方的域名 "),e("a",_,[t("www.pzijun.cn"),r(n)]),t(" 找到对方 "),e("a",u,[D,r(n)])]),g,P,e("ul",null,[N,e("li",null,[t("顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级 域名服务器可以返回 "),e("a",S,[t("apple.com"),r(n)]),t(" 域名服务器的 IP 地址")]),e("li",null,[t("权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 "),e("a",f,[t("apple.com"),r(n)]),t(" 权威域名服务器可以返回 "),e("a",m,[t("www.pzijun.cn"),r(n)]),t(" 的 IP 地址")])]),e("p",null,[t("有了👆这个系统后，任何域名都可以在上面这个结构中进行从上到下查询，例如，你要访问“"),e("a",T,[t("www.pzijun.cn"),r(n)]),t("”，就要进行下面的三次查询：")]),e("p",null,[e("a",C,[b,r(n)])]),e("p",null,[t("访问根域名服务器，它会告诉你“cn”顶级域名服务器的地址； 访问“cn”顶级域名服务器，它再告诉你“"),e("a",w,[t("pzijun.com"),r(n)]),t("”域名服务器的地址； 最后访问“"),e("a",k,[t("pzijun.com"),r(n)]),t("”域名服务器，就得到了“"),e("a",I,[t("www.pzijun.cn"),r(n)]),t("”的地址 但如果全世界的域名解析都往这个系统里挤，这个系统可能被挤瘫痪了，即使不瘫痪，解析速度也会大打折扣，所以 DNS 采取了一种非常有效的手段来解决这个问题： "),x]),z,U,j,e("p",null,[e("a",y,[v,r(n)])]),M,e("p",null,[e("a",E,[L,r(n)])]),B,e("p",null,[e("a",V,[F,r(n)])]),H,e("p",null,[e("a",W,[G,r(n)])]),R,X,q,J,Y,A,K,e("p",null,[t("TCP 建立连接需要进行三次网络通信； TCP 建立连接需要传输 ~130 字节的数据； TCP 销毁连接需要进行四次网络通信； TCP 销毁连接需要传输 ~160 字节的数据； 假设网络通信所消耗的时间是可以忽略的不计的，如果我们只考虑 TCP 建立连接时传输的数据的话，可以简单来算一笔账： "),e("a",O,[Z,r(n)])]),Q,e("p",null,[e("a",$,[ee,r(n)])]),te,ne,re,oe])}const he=l(c,[["render",le],["__file","DNS.html.vue"]]);export{he as default};
