import{_ as p}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as T,c as o,a as d,b as t,d as a,f as e,r as n}from"./app.4684ad3e.js";const i={},h=e('<h1 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h1><p>超文本传送协议HTTP 是面向事务的应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。 主要特点</p><ol><li><p>HTTP 是面向事务的客户服务器协议。所谓面向事务：一系列的信息交换，这一系列的信息交换是不可分割的整体，要么所有信息交换完成，要么一次交换都不进行。</p></li><li><p>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务，但通信双方在交换HTTP报文之前不需要先建立HTTP连接。</p></li><li><p>HTTP 1.0 协议是无状态的(stateless)，即对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息。 ###HTTP 的操作过程</p></li><li><p>每个万维网网点都有一个服务器进程，它不断监听TCP的端口80，以便发现是否有浏览器向它发出连接建立请求。</p></li><li><p>监听到连接建立请求并建立TCP连接</p></li><li><p>浏览器向该万维网服务器发出浏览某个页面的请求</p></li><li><p>服务器返回所请求的页面</p></li><li><p>释放TCP连接 当您在Web浏览器中键入URL时，会发生什么？ 简答：</p></li></ol><p>DNS解析→TCP连接→发送HTTP请求→服务器处理请求并返回HTTP报文→浏览器解析渲染页面→连接结束</p><p>(1) 浏览器分析超链指向页面的 URL。</p>',5),s={href:"http://www.tsinghua.edu.cn",target:"_blank",rel:"noopener noreferrer"},P=e('<p>(3) 域名系统 DNS 解析出清华大学服务器的 IP 地址。</p><p>(4) 浏览器与服务器建立 TCP 连接（服务器监听80端口）</p><p>(5) 浏览器发出取文件命令： GET /chn/yxsz/index.htm。</p><p>(6) 服务器给出响应，把文件 index.htm 发给浏览器。</p><p>(7) TCP 连接释放。</p><p>(8) 浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。</p><h2 id="http-常见的状态码" tabindex="-1"><a class="header-anchor" href="#http-常见的状态码" aria-hidden="true">#</a> HTTP 常见的状态码</h2><p>状态码分类：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><hr><p>状态码列表：</p><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="get-与-post" tabindex="-1"><a class="header-anchor" href="#get-与-post" aria-hidden="true">#</a> GET 与 POST</h2><p>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。 POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。 比如，你在我文章底部，敲入了留言后点击「提交」，浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。 区别： ① get是从服务器上获取数据，post是向服务器传送数据。</p><p>get 和 post只是一种传递数据的方式，get也可以把数据传到服务器，他们的本质都是发送请求和接收结果。只是组织格式和数据量上面有差别</p><p>② get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</p><p>③ 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</p><p>④ get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 post基本没有限制。</p><p>⑤ get安全性非常低，post安全性较高。 因为参数直接暴露在URL上，所以不建议使用get请求来传递敏感信息。</p><p>⑥ GET在浏览器回退时是无害的，而POST会再次提交请求。</p><p>⑦ GET请求只能进行url编码，而POST支持多种编码方式。</p><p>⑧ GET请求会被浏览器主动缓存，而POST不会，除非手动设置。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</p><p>⑨ GET请求在URL中传送的参数是有长度限制的，而POST没有。对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 其他区别：</p><p>1） . 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>2）. GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的。由于GET请求一般是用于资源信息的获取而非修改，所以GET意味着所谓的安全。换言之，GET请求一般不会产生副作用，它仅仅是获取资源信息，就像数据库查询一样，不会改变数据，不会影响资源的状态。所以，GET请求不一般会改变服务器状态。幂等意味着对于同一个URL的多个请求应该返回同样的结果。GET方法的报文主体没有任何语义</p><p>3） . POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存</p><p>4） . GET是通过URL方式请求，可以直接看到，明文传输。POST是通过请求header请求，可以开发者工具或者抓包可以看到，同样也是明文的。</p><h2 id="http与https" tabindex="-1"><a class="header-anchor" href="#http与https" aria-hidden="true">#</a> HTTP与HTTPS</h2><p>HTTP 与 HTTPS 有哪些区别？</p><p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。</p><p>HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</p><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进SSL/TLS 的握手过程，才可进入加密报文传输。</p><p>HTTP 的端口号是 80，HTTPS 的端口号是 443。</p><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p><p>HTTPS 解决了 HTTP 的哪些问题？ 1、HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><p>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</p><p>篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</p><p>冒充风险，比如冒充淘宝网站，用户钱容易没。</p><p>2、 HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。（https的SSL加密是在传输层实现的。） <figure><img src="https://img-blog.csdnimg.cn/20210105155555942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzUxNDY1,size_16,color_FFFFFF,t_70" alt="" title="RUNOOB" loading="lazy"><figcaption>RUNOOB</figcaption></figure></p><p>3、HTTP 与 HTTPS可以很好的解决了上述的风险：</p><p>信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</p><p>校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</p><p>身份证书：证明淘宝是真的淘宝网</p>',43);function l(c,S){const r=n("ExternalLinkIcon");return T(),o("div",null,[h,d("p",null,[t("(2) 浏览器向 DNS 请求解析 "),d("a",s,[t("www.tsinghua.edu.cn"),a(r)]),t(" 的 IP 地址。（浏览器首先在缓存中查找，查找的顺序是浏览器缓存→系统缓存→路由器缓存，缓存中查找不到则去系统的hosts文件中查找，没有则查询DNS服务器）")]),P])}const R=p(i,[["render",l],["__file","HTTP.html.vue"]]);export{R as default};
